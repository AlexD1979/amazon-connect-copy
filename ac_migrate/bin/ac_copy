#!/bin/bash

############################################################
#
# Copy Amazon Connect instance A to instance B safely
#

VERSION=1.2.2b
SCRIPT_VERSION="$(basename $0) $VERSION"

# Usage: $(basename $0) [-?deCv] helper
#     -C      Produce compact contact flow/module JSON files (for the updated targetflows/modules)

USAGE=$(cat <<EOD
Usage: $(basename $0) [-?dev] helper
    Copy Amazon Connect instance A to instance B safely, based on the
    connect_save and connect_diff results, under the helper directory
    creating new components in helper.new, updating old components in helper.old,
    and updating references defined in helper.sed.

    helper  Name of the helper directory
    -d      Dry run - Run through the script but not updating the target instance
    -e      Proceed even when the system may not encode Extended ASCII characters properly
    -v      Show version of this script
    -?      Help
EOD
)
usage() { echo -e "$USAGE" >&2; exit 2; }
version() { echo -e "$SCRIPT_VERSION"; exit; }
dos2unix() { tr -d '\r'; }

error() {
    if [[ ! "$1" =~ ^[[:digit:]]+$ ]]; then
        # Not an AWS CLI error
        cat <<EOD >&2
Error: $*
EOD
    else
        # An AWS CLI error
        line_no=$1
        shift
        cat <<EOD >&2
$*
Error at line ${line_no}. Recommended actions:
Make sure all required prompts exist in the target instance, and
Install the latest AWS CLI: https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html .
EOD
    fi
    exit 1
}

hex_cmd=
if [ -x "$(command -v xxd)" ]; then
  hex_cmd="xxd -u -p -c1"
elif [ -x "$(command -v hexdump)" ]; then
  hex_cmd="hexdump -v -e '/1 \"%02X\n\"'"
elif [ -x "$(command -v od)" ]; then
  hex_cmd="od -An -vtx1 | tr [:lower:] [:upper:] | for i in \$(cat); do echo \$i; done"
fi
test -z "$hex_cmd" && error "Cannot find any hex conversion commands. Please install one of these: xxd, hexdump, od"
hex_code() { printf '%s' "$1" | eval "$hex_cmd" | while read x; do printf "%%%s" "$x"; done }
# hex_code() { printf '%s' "$1" | xxd -u -p -c1 | while read x; do printf "%%%s" "$x"; done }

path_encode()  {
    old_lc_collate=$LC_COLLATE
    LC_COLLATE=C
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:$i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf '%s' "$c";;
            *) x=$(hex_code "$c"); echo -n ${x//%0D/};;
        esac
    done
    LC_COLLATE=$old_lc_collate
}

path_decode() {
    local path_encoded="${1//+/ }"
    printf '%b' "${path_encoded//%/\\x}"
}

diff_files() {
    # Compare TEMPA (sedded into TEMP1 and sorted into TEMP2) and TEMPB (sorted inline).
    # If same, return 0. If different, show the difference unsorted,
    # then ask if want to update. Return 1 if needs update and 0 otherwise.
    sed -f "$helper_sed" $TEMPA | tee $TEMP1 | sort > $TEMP2
    sort $TEMPB | diff -qbB - $TEMP2 &> /dev/null
    if [ $? -eq 0 ]; then
        echo "same"
    else
        # sdiff $TEMPB $TEMP1
        echo "changed"
    fi
}

sub_lex_bot() {
    if [ -z "$lex_bot_prefix_a" -a -z "$lex_bot_prefix_b" ]; then
        cat
    else
        cat > $TEMP1
        local lexExists=$(cat $TEMP1 | jq ".Actions[] | select(.Type == \"ConnectParticipantWithLexBot\") | has(\"Type\")")
        if [ -z "$lexExists" ]; then
            cat $TEMP1
        else
            cat $TEMP1 | jq "
.Actions[] |
if .Type == \"ConnectParticipantWithLexBot\"
then .Parameters.LexBot.Name = (.Parameters.LexBot.Name |
    sub(\"^$lex_bot_prefix_a\"; \"$lex_bot_prefix_b\"))
else .
end
" > $TEMP2
            cat $TEMP1 |
            jq -r --slurpfile actions $TEMP2 ".Actions = \$actions"
        fi
    fi
}

# AWS CLI needs to output JSON
export AWS_DEFAULT_OUTPUT=json
aws_connect() {
    local cmd=""
    local ii
    for ii; do
        [[ "$ii" =~ " " || "$ii" =~ "(" || "$ii" =~ ")" ]] && cmd="$cmd \"$ii\"" || cmd="$cmd $ii"
    done
    echo "aws connect$profile_flag$cmd" >> "$aws_cli_log"
    eval "aws connect$profile_flag$cmd" 2> $TEMPERR
    local ret=$?
    if [ -s $TEMPERR ]; then
        cat $TEMPERR | tee -a "$aws_cli_log" >&2
    fi
    return $ret
}

## Max Queue Configs in a routing profile cannot be greater than 10
MaxQC=10
## Max contacts in a queue defaults to 2610 in certain cases. This can cause an error while updating queue
MaxContacts=2610

TEMPFILE=$(mktemp)
TEMPERR=${TEMPFILE}_err
TEMPNEW=${TEMPFILE}_new
TEMPOLD=${TEMPFILE}_old
TEMPA=${TEMPFILE}_A
TEMPB=${TEMPFILE}_B
TEMPA2=${TEMPFILE}_A2
TEMPA3=${TEMPFILE}_A3
TEMPA4=${TEMPFILE}_A4
TEMP1=${TEMPFILE}_1
TEMP2=${TEMPFILE}_2
trap 'rm -r -- $TEMPFILE $TEMPERR $TEMPNEW $TEMPOLD $TEMPA $TEMPB $TEMPA2 $TEMPA3 $TEMPA4 $TEMP1 $TEMP2' EXIT
touch $TEMPFILE $TEMPERR $TEMPNEW $TEMPOLD $TEMPA $TEMPB $TEMPA2 $TEMPA3 $TEMPA4 $TEMP1 $TEMP2

## Set directories
scriptPath=$(readlink -f "$0")
homedir=$(dirname "$(dirname "$scriptPath")")
rscdir="${homedir}/resources"

## Added flow exception file to skip flows that cannot be migrated. e.g. Can contain caller-id setting of claimed number from source account
## e.g. lambda src-function-name dest-function-name
## Setting default flow execptions file - if phone mapping was configured then helper.var will override variable with "flowExceptions_phone"
flowExceptions="${rscdir}/flowExceptions"
phoneMapping="${rscdir}/flowExceptions_phone"

actionLead="# Action -"
dryrun=
ignore_improper_extended_ascii=
while getopts "?dev" arg; do
    case "$arg" in
    d)  dryrun=on; echo "Dry Run";;
    e)  ignore_improper_extended_ascii=on;;
    # C)  jq_compact_flag=" -c";;
    v)  version;;
    *)  usage;;
    esac
done
shift $((OPTIND-1))

if [ "$(hex_code "é")" != "%C3%A9" ]; then
    echo "WARNING: This system may not encode Extended ASCII characters properly." >&2
    if [ -n "$ignore_improper_extended_ascii" ]; then
        echo "Proceed regardless as the -e option is specified." >&2
    else
        cat <<EOD >&2

If your instance component names contain Extended ASCII characters, such as accented letters
like é, this system will encode those names differently from standard encoding.

If you are sure that your component names do not contain Extended ASCII characters,
you may proceed regardless by running the command again with the -e option.
EOD
        exit 1
    fi
fi

helper=$1

if [ -z "$helper" ]; then
    usage
fi

for ext in var sed new old del skip; do
    eval helper_$ext="$helper/helper.$ext"
done

if [ ! -s "$helper_var" ]; then
    error "\"$helper_var\" does not exist. \"$helper\" is probably not a Helper directory."
fi

. "$helper_var"
profile=$aws_profile_b
profile_flag=${profile:+ --profile $profile}
account_b=$aws_ac_b

cat <<EOD
Instance Alias A: $instance_alias_a (in directory "$instance_alias_dir_a")
Instance Alias B: $instance_alias_b (in directory "$instance_alias_dir_b")
Helper Directory: $helper
AWS Profile B in use: ${profile:-${AWS_PROFILE:-(default)}}
Context Flow Prefix: $contact_flow_prefix
EOD

contact_flow_prefix_encoded=$(path_encode "$contact_flow_prefix")
contact_flow_prefix_text="${contact_flow_prefix:+ with names prefixed with \"$contact_flow_prefix\"}"

helper_older_than=

if [ "$helper_var" -ot "$instance_alias_dir_a/instance.var" ]; then
    helper_older_than="$helper_older_than $instance_alias_a"
fi

if [ "$helper_var" -ot "$instance_alias_dir_b/instance.var" ]; then
    helper_older_than="$helper_older_than $instance_alias_b"
fi

if [ -n "$helper_older_than" ]; then
    echo
    error "Instances$helper_older_than updated since helper \"$helper\" was created. Please run connect_diff again."
fi

helper_log="${helper%/}.log"
aws_cli_log="$helper_log"
cat <<EOD > "$helper_log"
# This log file is for AWS CLI tracing, not for direct execution.
# Please use the $(basename $0) command (in non-dry-run mode) to perform the copying instead.
#
EOD

if [ -n "$dryrun" ]; then
    cat <<EOD >> "$helper_log"
# Dry-run mode - Actions listed below are not being carried out
#
EOD
fi

if [ -z "$dryrun" ]; then
   read -p "Do you want to start migration from source instance ("$instance_alias_a") to destination instance ("$instance_alias_b") (yes/no): "    ans
   if [ "$ans" != "yes" ]; then
        echo "Exiting migration..."
        exit 0
   fi
fi
############################################################
## Creating list of newly created resources that can be deleted from instance B
	echo "## Newly created resources in instance B that can be removed (except queues, routingprofiles and hours of operation)" > $helper_del
	echo "instance_${instance_alias_dir_b}|$instance_id_b" >> $helper_del

## Skipped modules and flows due to hard-coded caller Id settings
	echo "instance_${instance_alias_dir_b}|$instance_id_b" > $helper_skip

############################################################
#
# Prompts
#

cat <<EOD

Prompts
-------
EOD

egrep -q "^prompt_" "$helper_new"
if [ $? -eq 1 ]; then
    echo "All prompts in the source instance exist in the target instance."
else
    echo "These prompts are found in the source instance but do not exist in the target instance."
    echo "Manual upload required:"
    egrep "^prompt_" "$helper_new" | sort | sed -e's/_/: /'
fi


############################################################
#
# Hours of operations
#

cat <<EOD

Hours of operations
-------------------
EOD
# Preload as $helper_old may change
egrep "^hour_" "$helper_old" > $TEMPOLD
# Create what is in $helper_new
egrep "^hour_" "$helper_new" > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
    echo "No hours of operations to create"
else
    num_hours=$(echo $(cat $TEMPNEW | wc -l))
    echo -e "\nCreating $num_hours Hours of operations"
    ii=0
    sort $TEMPNEW |
    while read hour_json; do
        ii=$[ii+1]
        echo "$ii. $hour_json"
        hour_name=${hour_json#hour_}
        hour_name=${hour_name%.json}
        hour_name_decoded=$(path_decode "$hour_name")
	h_desc_new=$hour_name_decoded

        hour_id_a=$(jq -r ".HoursOfOperation.HoursOfOperationId" "$instance_alias_dir_a/$hour_json" | dos2unix)
################
	## Lets make sure description is not null
	hour_desc=$(jq -r ".HoursOfOperation.Description" "$instance_alias_dir_a/$hour_json" | dos2unix)

	## if description does not exist then set to same as name
	if [ "$hour_desc" = "null" -o "$hour_desc" = "" ]; then
		## There is no description for hours - set it to default
                cat "$instance_alias_dir_a/$hour_json" | jq --arg hour_desc_new "$h_desc_new" \
                        ".HoursOfOperation | del(.Description) | . + { Description: \$hour_desc_new}" > "$TEMPA"
	        cat "$TEMPA" |
        		jq --arg iid $instance_id_b \
          	  	"del(.HoursOfOperationId, .HoursOfOperationArn) | . + { InstanceId: \$iid}" |
            		sed -f "$helper_sed" > "$helper/$hour_json"

	else
		## Hours description exists
	        cat "$instance_alias_dir_a/$hour_json" |
	        	jq --arg iid $instance_id_b \
    	       		 ".HoursOfOperation | del(.HoursOfOperationId, .HoursOfOperationArn) | . + { InstanceId: \$iid}" |
            		sed -f "$helper_sed" > "$helper/$hour_json"

	fi

        cat <<EOD >> "$helper_log"

$actionLead Create hours of operation: $hour_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-create hours of operation
$(cat "$helper/$hour_json")

EOD
            cat <<EOD >> "$helper_log"
aws connect create-hours-of-operation \
--cli-input-json "file://$helper/$hour_json" \
> "$helper/output_$hour_json"
EOD
            # rm "$helper/$hour_json"
            continue
        fi

        aws_connect create-hours-of-operation \
            --cli-input-json "file://$helper/$hour_json" \
            > "$helper/output_$hour_json" || error $LINENO
        hour_id_b=$(jq -r ".HoursOfOperationId" "$helper/output_$hour_json" | dos2unix)
        aws_connect describe-hours-of-operation \
            --instance-id $instance_id_b \
            --hours-of-operation-id $hour_id_b \
            > "$instance_alias_dir_b/$hour_json" || error $LINENO

## Creating list of newly created resources that can be deleted from instance B
	echo "hour_${hour_name_decoded}|$hour_id_b" >> $helper_del
##
        # Moving hour_json from helper_new to helper_old
        echo $hour_json >> "$helper_old"
        sed -e"/$hour_json/d" "$helper_new" > $TEMPFILE
        cat $TEMPFILE > "$helper_new"

        cat <<EOD >> "$helper_sed"
# Hour of operation: $hour_name_decoded
s%$hour_id_a%$hour_id_b%g
EOD
    done
    test $? -eq 0 || error

    if [ -z "$dryrun" ]; then
        # Update instance B hours
        aws_connect list-hours-of-operations \
            --instance-id $instance_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r ".HoursOfOperationSummaryList[]" > "$instance_alias_dir_b/hours.json"
    fi
fi

if [ ! -s $TEMPOLD ]; then
    echo "No hours of operations to update"
else
    num_hours=$(echo $(cat $TEMPOLD | wc -l))
    echo -e "\nChecking $num_hours hours of operations for an update"
    ii=0
    sort $TEMPOLD |
    while read hour_json; do
        ii=$[ii+1]
        echo -n "$ii. $hour_json ... "
        hour_name=${hour_json#hour_}
        hour_name=${hour_name%.json}
        hour_name_decoded=$(path_decode "$hour_name")
        cat "$instance_alias_dir_a/$hour_json" > $TEMPA
        cat "$instance_alias_dir_b/$hour_json" > $TEMPB
        df=$(diff_files); echo $df; test "$df" == "same" && continue
        echo "Updating $hour_json"

	hour_id_b=$(jq -r ".HoursOfOperation.HoursOfOperationId" "$instance_alias_dir_b/$hour_json" | dos2unix)
        arg_flags=$(cat "$instance_alias_dir_b/$hour_json" |
		jq -r ".HoursOfOperation | \"--arg id \" + .HoursOfOperationId" | dos2unix)
        cat "$instance_alias_dir_a/$hour_json" |
        jq --arg iid $instance_id_b $arg_flags \
            ".HoursOfOperation | del(.HoursOfOperationArn, .Tags) | . + { InstanceId: \$iid, HoursOfOperationId: \$id }" \
            > "$helper/$hour_json"

        cat <<EOD >> "$helper_log"

$actionLead Update hours of operation: $hour_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-update hours of operation
$(cat "$helper/$hour_json")

EOD
            cat <<EOD >> "$helper_log"
aws connect update-hours-of-operation \
--cli-input-json "file://$helper/$hour_json" \
> "$helper/output_$hour_json"
EOD
            # rm "$helper/$hour_json"
            continue
        fi

        aws_connect update-hours-of-operation \
            --cli-input-json "file://$helper/$hour_json" \
            > "$helper/output_$hour_json" || error $LINENO

        aws_connect describe-hours-of-operation \
            --instance-id $instance_id_b \
            --hours-of-operation-id $hour_id_b \
            > "$instance_alias_dir_b/$hour_json" || error $LINENO
    done
    test $? -eq 0 || error
fi


############################################################
#
# Queues
#

cat <<EOD

Queues
------
EOD
# Preload as $helper_old may change
egrep "^queue_" "$helper_old" > $TEMPOLD
# Create what is in $helper_new
egrep "^queue_" "$helper_new" > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
    echo "No queues to create"
else
    num_queues=$(echo $(cat $TEMPNEW | wc -l))
    echo -e "\nCreating $num_queues queues"
    ii=0
    sort $TEMPNEW |
    while read queue_json; do
        ii=$[ii+1]
        echo "$ii. $queue_json"
        queue_name=${queue_json#queue_}
        queue_name=${queue_name%.json}
        queue_name_decoded=$(path_decode "$queue_name")
	q_desc_new=$queue_name_decoded

	queue_id_a=$(jq -r ".Queue.QueueId" "$instance_alias_dir_a/$queue_json" | dos2unix)

################
	## Lets make sure queue description is not null and max contacts not equal to MaxContacts
	queue_desc=$(jq -r ".Queue.Description" "$instance_alias_dir_a/$queue_json" | dos2unix)
	max_contacts=$(jq -r ".Queue.MaxContacts" "$instance_alias_dir_a/$queue_json" | dos2unix)
	if [ $max_contacts = null ]; then
		max_contacts=0
	fi

	## Let's set flags to determine what need to be updated
	maxc=no	# No need to update max contacts
	qdesc=yes # Queue description exists
	# Max contacts in a queue cannot be MaxContacts
        if [ $max_contacts -eq $MaxContacts ]; then
		maxc=yes
	fi
	if [ "$queue_desc" = "null" -o "$queue_desc" = "" ]; then
		qdesc=no
	fi

	# Now lets check and update as appropriate
        if [ "$maxc" = "no" -a "$qdesc" = "yes" ]; then
                ## Max contacts in a queue is good and queue description exist
	        cat "$instance_alias_dir_a/$queue_json" |
        		jq --arg instance_id $instance_id_b \
           		 ".Queue | del(.QueueId, .QueueArn, .OutboundCallerConfig, .Status) | . + { InstanceId: \$instance_id}" |
       		 sed -f "$helper_sed" > "$helper/$queue_json"
	elif [ "$maxc" = "no" -a "$qdesc" = "no" ]; then
		## Max contacts in a queue is good but queue description does not exist
                ## Set queue description to same as queue name
                cat "$instance_alias_dir_a/$queue_json" | jq --arg queue_desc_new "$q_desc_new" \
                        ".Queue | del(.Description) | . + { Description: \$queue_desc_new}" > "$TEMPA"
                cat "$TEMPA" | jq --arg instance_id $instance_id_b \
                        "del(.QueueId, .QueueArn, .OutboundCallerConfig, .Status) | . + { InstanceId: \$instance_id}" |
      	 		 sed -f "$helper_sed" > "$helper/$queue_json"
	elif [ "$maxc" = "yes" -a "$qdesc" = "yes" ]; then
                ## Max contacts in a queue is NOT good and queue description exist
		## Remove Max contacts
	        cat "$instance_alias_dir_a/$queue_json" |
        		jq --arg instance_id $instance_id_b \
           		 ".Queue | del(.QueueId, .QueueArn, .OutboundCallerConfig, .Status, .MaxContacts) | . + { InstanceId: \$instance_id}" |
       		 sed -f "$helper_sed" > "$helper/$queue_json"
	else
		## Max contacts in a queue is NOT good and queue description does not exist
		## Remove Max contacts and Set queue description to same as queue name
                cat "$instance_alias_dir_a/$queue_json" | jq --arg queue_desc_new "$q_desc_new" \
                        ".Queue | del(.Description) | . + { Description: \$queue_desc_new}" > "$TEMPA"
                cat "$TEMPA" | jq --arg instance_id $instance_id_b \
                        "del(.QueueId, .QueueArn, .OutboundCallerConfig, .Status, .MaxContacts) | . + { InstanceId: \$instance_id}" |
      	 		 sed -f "$helper_sed" > "$helper/$queue_json"
        fi
################

        cat <<EOD >> "$helper_log"

$actionLead Create queue: $queue_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-create queue
$(cat "$helper/$queue_json")

EOD
            cat <<EOD >> "$helper_log"
aws connect create-queue \
--cli-input-json "file://$helper/$queue_json" \
> "$helper/output_$queue_json"
EOD
            # rm "$helper/$queue_json"
            continue
        fi

        aws_connect create-queue \
            --cli-input-json "file://$helper/$queue_json" \
            > "$helper/output_$queue_json" || error $LINENO
	queue_id_b=$(jq -r ".QueueId" "$helper/output_$queue_json" | dos2unix)

        aws_connect describe-queue \
            --instance-id $instance_id_b \
            --queue-id $queue_id_b \
            > "$instance_alias_dir_b/$queue_json" || error $LINENO

	## There will not be any quick-connects associated with the newly created queue. Create an empty file for later comparison
## 	aws_connect list-queue-quick-connects \
##        	--instance-id $instance_id_b \
##        	--queue-id $queue_id_b \
##        	> "$instance_alias_dir_b/queue_qc_$queue_name_decoded.json" || error $LINENO

	echo '{
    "QuickConnectSummaryList": []
}'         	> "$instance_alias_dir_b/queue_qc_$queue_name.json"

## Creating list of newly created resources that can be deleted from instance B
	echo "queue_${queue_name_decoded}|$queue_id_b" >> $helper_del
###############

        # Moving queue_json from helper_new to helper_old
        echo $queue_json >> "$helper_old"
        sed -e"/$queue_json/d" "$helper_new" > $TEMPFILE
        cat $TEMPFILE > "$helper_new"

        cat <<EOD >> "$helper_sed"
# Queue: $queue_name_decoded
s%$queue_id_a%$queue_id_b%g
EOD
    done
    test $? -eq 0 || error

    if [ -z "$dryrun" ]; then
        # Update instance B queues
        aws_connect list-queues \
            --instance-id $instance_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r ".QueueSummaryList[] | select(.QueueType != \"AGENT\")" > "$instance_alias_dir_b/queues.json"
    fi
fi

## Load helper_old so that we can check if queues in destination instance need update of hours of operation
egrep "^queue_" "$helper_old" > $TEMPOLD
if [ ! -s $TEMPOLD ]; then
    echo "No queues to update"
else
    num_queues=$(echo $(cat $TEMPOLD | wc -l))
    echo -e "\nChecking $num_queues queues for hours of operations update"
    ii=0
    sort $TEMPOLD |
    while read queue_json; do
        ii=$[ii+1]
        echo -n "$ii. $queue_json ... "
        queue_name=${queue_json#queue_}
        queue_name=${queue_name%.json}
        queue_name_decoded=$(path_decode "$queue_name")

        hours_of_operations_id_a=$(jq -r ".Queue.HoursOfOperationId" "$instance_alias_dir_a/$queue_json" | dos2unix)
        hours_of_operations_id_b=$(jq -r ".Queue.HoursOfOperationId" "$instance_alias_dir_b/$queue_json" | dos2unix)
        echo $hours_of_operations_id_a > $TEMPA
        echo $hours_of_operations_id_b > $TEMPB
        df=$(diff_files); echo $df; test "$df" == "same" && continue

        ## We have to update Queue hours of operations
    	queue_id_b=$(jq -r ".Queue.QueueId" "$instance_alias_dir_b/$queue_json" | dos2unix)
        echo '{
                "InstanceId": ''"'$instance_id_b'",
                "QueueId" : ''"'$queue_id_b'",
                "HoursOfOperationId": ''"'$hours_of_operations_id_a'"
            }' | sed -f "$helper_sed" > "$helper/queue_hours_$queue_name.json"

        cat <<EOD >> "$helper_log"

        $actionLead Update Queue hours of operations: $queue_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-update Queue hours of operation
$(cat "$helper/queue_hours_$queue_name.json")

EOD
            cat <<EOD >> "$helper_log"
aws connect update-queue-hours-of-operation \
--cli-input-json "file://$helper/queue_hours_$queue_name.json" \
> "$helper/output_queue_hours_$queue_name.json"
EOD
            continue
        fi

        aws_connect update-queue-hours-of-operation \
            --cli-input-json "file://$helper/queue_hours_$queue_name.json" \
            > "$helper/output_queue_hours_$queue_name.json" || error $LINENO

    done
fi

############################################################
#
# Routing Profiles
#

gen_helper_rpqr() {
    # Routing Profile Queue Reference
    routing_name=$1
    out_file="$helper/routingQRs_$routing_name.json"
## If queue config in a routing profile exceeds count of 10 then it cannot be updated
    rpqcnt=`cat "$instance_alias_dir_a/routingQs_$routing_name.json" |grep "QueueId" | wc -l`
    if [ $rpqcnt -gt $MaxQC ]; then
	## Queue configuration in routing profile exceeds maximum that can be used with API - take maximum (defined in variable MaxQC)
	k=0
	while [ $k -lt $MaxQC ]; do
        	cat "$instance_alias_dir_a/routingQs_$routing_name.json" |  jq ".RoutingProfileQueueConfigSummaryList[$k] | { QueueReference: { QueueId, Channel }, Priority, Delay }"  >> "$out_file"
         	k=`expr $k + 1`
	done
       echo "$out_file"
    else
       cat "$instance_alias_dir_a/routingQs_$routing_name.json" |
       jq ".RoutingProfileQueueConfigSummaryList[] |
           { QueueReference: { QueueId, Channel }, Priority, Delay }" \
       > "$out_file"
       echo "$out_file"
    fi
}

gen_helper_routing_new() {
    routing_name=$1
    out_file="$helper/routingNew_$routing_name.json"
    rpqr_file=$(gen_helper_rpqr "$routing_name")
    cat "$instance_alias_dir_a/routing_$routing_name.json" |
    jq --arg iid $instance_id_b \
        --slurpfile rpqc "$rpqr_file" \
        ".RoutingProfile |
        del(.RoutingProfileId, .RoutingProfileArn) |
        . + { InstanceId: \$iid, QueueConfigs: \$rpqc } |
        del(.MediaConcurrencies[] | select(.Concurrency == 0))" |
    sed -f "$helper_sed" > "$out_file"
    rm "$rpqr_file"
    echo "$out_file"
}

gen_helper_routing_old() {
    routing_name=$1
    out_file="$helper/routingOld_$routing_name.json"
    rpqr_file=$(gen_helper_rpqr "$routing_name")
    cat "$instance_alias_dir_b/routing_$routing_name.json" |
    jq --arg iid $instance_id_b \
        --slurpfile rpqc "$rpqr_file" \
        ".RoutingProfile |
        { InstanceId, RoutingProfileId, QueueConfigs: \$rpqc }" |
    sed -f "$helper_sed" > "$out_file"
    rm "$rpqr_file"
    echo "$out_file"
}

cat <<EOD

Routing Profiles
----------------
EOD
# Preload as $helper_old may change
egrep "^routing_" "$helper_old" > $TEMPOLD
# Create what is in $helper_new
egrep "^routing_" "$helper_new" > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
    echo "No routing profiles to create"
else
    num_routings=$(echo $(cat $TEMPNEW | wc -l))
    echo -e "\nCreating $num_routings routing profiles"
    ii=0
    sort $TEMPNEW |
    while read routing_json; do
        ii=$[ii+1]
        echo "$ii. $routing_json"
        routing_name=${routing_json#routing_}
        routing_name=${routing_name%.json}
        routing_name_decoded=$(path_decode "$routing_name")

	routing_id_a=$(jq -r ".RoutingProfile.RoutingProfileId" "$instance_alias_dir_a/$routing_json" | dos2unix)
        routing_new_file=$(gen_helper_routing_new "$routing_name" | dos2unix)
        out_file="$helper/output_routing_new_$routing_name.json"

        cat <<EOD >> "$helper_log"

$actionLead Create routing profile: $routing_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-create routing profile
$(cat "$routing_new_file")

EOD
            cat <<EOD >> "$helper_log"
aws connect create-routing-profile \
--cli-input-json "file://$routing_new_file" \
> "$out_file"
EOD
            # rm "$routing_new_file"
            continue
        fi

        aws_connect create-routing-profile \
            --cli-input-json "file://$routing_new_file" \
            > "$out_file" || error $LINENO
	routing_id_b=$(jq -r ".RoutingProfileId" "$out_file" | dos2unix)

        # All routing profiles will be updated with queues
        echo "$routing_json" >> $TEMPOLD

        aws_connect describe-routing-profile \
            --instance-id $instance_id_b \
            --routing-profile-id $routing_id_b \
            > "$instance_alias_dir_b/$routing_json" || error $LINENO

        aws_connect list-routing-profile-queues \
            --instance-id $instance_id_b \
            --routing-profile-id $routing_id_b \
            > "$instance_alias_dir_b/routingQs_$routing_name.json" || error $LINENO

## Creating list of newly created resources that can be deleted from instance B
	echo "routing_${routing_name_decoded}|$routing_id_b" >> $helper_del
###############

        # Moving routing_json from helper_new to helper_old
        echo "$routing_json" >> "$helper_old"
        sed -e"/$routing_json/d" "$helper_new" > $TEMPFILE
        cat $TEMPFILE > "$helper_new"

        cat <<EOD >> "$helper_sed"
# Routing Profile: $routing_name_decoded
s%$routing_id_a%$routing_id_b%g
EOD
    done
    test $? -eq 0 || error

    if [ -z "$dryrun" ]; then
        # Update instance B routing profiles
        aws_connect list-routing-profiles \
            --instance-id $instance_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r ".RoutingProfileSummaryList[]" > "$instance_alias_dir_b/routings.json"
    fi
fi

if [ ! -s $TEMPOLD ]; then
    echo "No routing profiles to update"
else
    num_routings=$(echo $(cat $TEMPOLD | wc -l))
    # echo $num_routings existing routing profiles: not to be auto-updated due to possible operation impact
    echo -e "\nChecking $num_routings routing profiles for an update"
    ii=0
    sort $TEMPOLD |
##### While reading routing json
    while read routing_json; do
        ii=$[ii+1]
        echo -n "$ii. $routing_json ... "
        routing_name=${routing_json#routing_}
        routing_name=${routing_name%.json}
        routing_name_decoded=$(path_decode "$routing_name")

        cat "$instance_alias_dir_a/$routing_json" |
        jq "del(.RoutingProfile.MediaConcurrencies[] | select(.Concurrency == 0))" > $TEMPA
        cat "$instance_alias_dir_b/$routing_json" |
        jq "del(.RoutingProfile.MediaConcurrencies[] | select(.Concurrency == 0))" > $TEMPB
        # df=$(diff_files); echo $df; test "$df" == "same" && continue
        df_r=$(diff_files)

        cat "$instance_alias_dir_a/routingQs_$routing_name.json" > $TEMPA
        cat "$instance_alias_dir_b/routingQs_$routing_name.json" > $TEMPB
        # df=$(diff_files); echo $df; test "$df" == "same" && continue
        df_rq=$(diff_files)

        if [ "$df_r" == "same" -a "$df_rq" == "same" ]; then
            echo same
            continue
        fi

        echo " routing $df_r routing-queues $df_rq"
        echo "Updating $routing_json"

        # routing_old_file=$(gen_helper_routing_old "$routing_name")
	routing_id_b=$(jq -r ".RoutingProfile.RoutingProfileId" "$instance_alias_dir_b/$routing_json" | dos2unix)

        if [ "$df_r" != "same" ]; then
            # Update Routing Profile of Instance B ahead of time
            # then update the concurrency and default-outbound-queue.
            # (The name must have already matched.)
            if [ -z "$dryrun" ]; then
                cat "$instance_alias_dir_a/$routing_json" |
                sed -f "$helper_sed" > "$instance_alias_dir_b/$routing_json"
            fi

            routing_doq_b=$(cat "$instance_alias_dir_b/$routing_json" | jq -r ".RoutingProfile.DefaultOutboundQueueId" | dos2unix)

            cat "$instance_alias_dir_b/$routing_json" |
            jq -r ".RoutingProfile.MediaConcurrencies[] | select(.Concurrency != 0)" | dos2unix |
            jq -s > "$helper/routingConcurrency_$routing_name.json"

            cat <<EOD >> "$helper_log"

$actionLead Update routing profile: $routing_name_decoded
EOD
            if [ -n "$dryrun" ]; then
                cat <<EOD
Dry-update routing profile default outbound queue to "$routing_doq_b"
Dry-update routing profile concurrency
$(cat "$helper/routingConcurrency_$routing_name.json")

EOD
                cat <<EOD >> "$helper_log"
aws connect update-routing-profile-default-outbound-queue \
--instance-id $instance_id_b \
--routing-profile-id $routing_id_b \
--default-outbound-queue-id $routing_doq_b
aws connect update-routing-profile-concurrency \
--instance-id $instance_id_b \
--routing-profile-id $routing_id_b \
--media-concurrencies "file://$helper/routingConcurrency_$routing_name.json"
EOD
                # rm "$helper/routingConcurrency_$routing_name.json"
            else
                aws_connect update-routing-profile-default-outbound-queue \
                    --instance-id $instance_id_b \
                    --routing-profile-id $routing_id_b \
                    --default-outbound-queue-id $routing_doq_b || error $LINENO

                aws_connect update-routing-profile-concurrency \
                    --instance-id $instance_id_b \
                    --routing-profile-id $routing_id_b \
                    --media-concurrencies "file://$helper/routingConcurrency_$routing_name.json" || error $LINENO

                aws_connect describe-routing-profile \
                    --instance-id $instance_id_b \
                    --routing-profile-id $routing_id_b \
                    > "$instance_alias_dir_b/$routing_json" || error $LINENO
            fi
        fi

#### Start of if queue configuration not same between source and destination routing profiles
        if [ "$df_rq" != "same" ]; then
            cat "$instance_alias_dir_a/routingQs_$routing_name.json" |
   ##           jq -r ".RoutingProfileQueueConfigSummaryList[].QueueName" |
   ## Above is commented out as it does not work if only priority and/or delay seconds are changed
                jq -r ".RoutingProfileQueueConfigSummaryList[]| {QueueName, Priority, Delay, Channel}" | jq -c |
                   sort > $TEMPA
## sort -u is an issue if other channel for same queue name is enabled; so removing "-u"
#                sort -u > $TEMPA

            cat "$instance_alias_dir_b/routingQs_$routing_name.json" |
   ##             jq -r ".RoutingProfileQueueConfigSummaryList[].QueueName" |
   ## Above is commented out as it does not work if only priority and/or delay seconds are changed
                jq -r ".RoutingProfileQueueConfigSummaryList[]| {QueueName, Priority, Delay, Channel}" | jq -c |
                sort > $TEMPB
## sort -u is an issue if other channel for same queue name is enable; so removing "-u"
#                sort -u > $TEMPB
            > $TEMPA2
            diff $TEMPA $TEMPB | grep "^< " | sed -e"s/^< //" | cut  -d',' -f1 | sed -e "s/{\"QueueName\"://g" | sed "s/\"//g" | sort -u |
            tee $TEMPA3 |
################ while start reading qconfiguration updates
            while read q_name; do
                > $TEMPA2
                > $TEMPA4
	### Following is used to associate queue to routing profile
                cat "$instance_alias_dir_a/routingQs_$routing_name.json" |
                    jq -r ".RoutingProfileQueueConfigSummaryList[] | select(.QueueName == \"$q_name\") | { QueueReference: { QueueId, Channel }, Priority, Delay }" >> $TEMPA2
	        cat $TEMPA2 | sed -f "$helper_sed" | jq -s > "$helper/routingQueueConfig_$routing_name.json"

	### Following is used to disassociate queue from routing profile
                cat "$instance_alias_dir_a/routingQs_$routing_name.json" |
                    jq -r ".RoutingProfileQueueConfigSummaryList[] | select(.QueueName == \"$q_name\") | { QueueId, Channel }" >> $TEMPA4
	        cat $TEMPA4 | sed -f "$helper_sed" | jq -s > "$helper/routingQueueConfigDIS_$routing_name.json"

                cat <<EOD >> "$helper_log"

$actionLead Associate queues to routing profile: $routing_name_decoded
EOD
               if [ -n "$dryrun" ]; then
                   cat <<EOD
Dry-associate queues to routing profile $routing_name_decoded
$(cat $TEMPA3)
$(cat $TEMPFILE)

EOD
                  cat <<EOD >> "$helper_log"
aws connect associate-routing-profile-queues \
--instance-id $instance_id_b \
--routing-profile-id $routing_id_b \
--queue-configs "file://$helper/routingQueueConfig_$routing_name.json"
EOD
                # rm "$helper/routingQueueConfig_$routing_name.json"
               else
	   	   ## It is not a dry run
		   ## First we need to disassociate queue config from routing profile and then associate it.
		   ## This is to make sure if only "Priority" and/or "Delay" parameters are changed in source then we are able to update it.
                   aws_connect disassociate-routing-profile-queues \
       	            --instance-id $instance_id_b \
               	    --routing-profile-id $routing_id_b \
                    --queue-references "file://$helper/routingQueueConfigDIS_$routing_name.json" || error $LINENO

                   aws_connect associate-routing-profile-queues \
       	            --instance-id $instance_id_b \
               	    --routing-profile-id $routing_id_b \
                    --queue-configs "file://$helper/routingQueueConfig_$routing_name.json" || error $LINENO
               fi   ### End of if dry run check

        done   ################ end of while for updating qconfiguration

	## If there was something different between source and destination instance and if we can't update
	## e.g. routing profile exists in both instances but queue configuration is fewer in source than in destination
	##      This can happen when someone updated the routing profile to remove a queue in source instance 
	if [ ! -s "$TEMPA3" -a -z "$dryrun" ]; then
		echo "Skipping this update. Please update $routing_json manually."
		echo "$routing_json|$routing_id_b" >> $helper_skip

                aws_connect list-routing-profile-queues \
                    --instance-id $instance_id_b \
                    --routing-profile-id $routing_id_b \
                    > "$instance_alias_dir_b/routingQs_$routing_name.json" || error $LINENO
	fi
     fi   #### End of if queue configuration not same between source and destination routing profiles
    done  ##### While end reading routing json
    test $? -eq 0 || error
fi
### End if for routing profiles to update

################ Associate Lex bot to Connect instance in destination account
###
# Associate what is in $helper_new
egrep "^lex_" "$helper_new" | sort -u > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
	echo "No bots to associate"
else
	num_bots=$(echo $(cat $TEMPNEW | wc -l))
	echo -e "\nAssociating $num_bots Lex bots"
	ii=0
	sort $TEMPNEW |
	while read botname; do
		ii=$[ii+1]
		echo "$ii. $botname"
		bot_name=${botname#lex_}
                cnt=`echo $bot_name | grep : | wc -l`
                if [ "$cnt" == "1" ]; then
                        ## This is Lex V2 bot
			lexversion=v2
                        botnameV2=`echo $bot_name | cut -f1 -d':'`
                        botaliasV2=`echo $bot_name | cut -f2 -d':'`
			## Get bot-Id of this V2 bot
			v2botid=`aws lexv2-models list-bots --profile $aws_profile_b | jq -r ".botSummaries[] | select(.botName == \"$botnameV2\") | { botId }" | jq -r ".botId"`
			## now get alias-id using botid
			v2aliasid=`aws lexv2-models list-bot-aliases --profile $aws_profile_b --bot-id $v2botid | jq -r ".botAliasSummaries[] | select(.botAliasName == \"$botaliasV2\") | { botAliasId }" | jq -r ".botAliasId"`
			## Now create bot Alias arn
			v2aliasarn=arn:aws:lex:$region_b:$account_b:bot-alias/$v2botid/$v2aliasid

			if [ -n "$dryrun" ]; then
				cat <<EOD
Dry-associating lambda function
--instance-id $instance_id_b \
--lex-v2-bot AliasArn=$v2aliasarn \

EOD
				cat <<EOD >> "$helper_log"
 
aws connect associate-bot \
--instance-id $instance_id_b \
--lex-v2-bot AliasArn=$v2aliasarn
EOD
		                continue
			fi
                else
                        ## This is Lex V1 bot
			lexversion=v1
			if [ -n "$dryrun" ]; then
				cat <<EOD
Dry-associating lambda function
--instance-id $instance_id_b \
--lex-bot Name=$bot_name,LexRegion=$region_b \

EOD
				cat <<EOD >> "$helper_log"

aws connect associate-bot \
--instance-id $instance_id_b \
--lex-bot Name=$bot_name,LexRegion=$region_b
EOD
		                continue
			fi
                fi

		## Not a dry run
		if [ "$lexversion" = "v1" ]; then
			aws_connect associate-bot \
				--instance-id $instance_id_b \
				--lex-bot Name=$bot_name,LexRegion=$region_b || error $LINENO
		else
			aws_connect associate-bot \
				--instance-id $instance_id_b \
				--lex-v2-bot AliasArn=$v2aliasarn || error $LINENO
		fi
	done
fi

############################################################
#
# Contact Flow Modules
#

cat <<EOD

Contact Flow Modules Creation
-----------------------------
EOD

# Preload as $helper_old may change
## Commenting out below egrep and adding one below. Only searching with "modules_"
##egrep "^module_$contact_flow_prefix" "$helper_old" > $TEMPOLD
egrep "^module_" "$helper_old" > $TEMPOLD
# Create what is in $helper_new
## Commenting out below egrep and adding one below. Only searching with "modules_"
#egrep "^module_$contact_flow_prefix" "$helper_new" > $TEMPNEW
egrep "^module_" "$helper_new" > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
    echo "No contact flow modules$contact_flow_prefix_text to create"
else
    num_modules=$(echo $(cat $TEMPNEW | wc -l))
    echo -e "\nCreating $num_modules contact flow modules$contact_flow_prefix_text"
    ii=0
    sort $TEMPNEW |
    while read module_json; do
        ii=$[ii+1]
        echo "$ii. $module_json"
        module_name=${module_json#module_}
        module_name=${module_name%.json}
        module_name_decoded=$(path_decode "$module_name")

        ## module_id_a=$(jq -r "select(.Name == \"$module_name_decoded\") | .Id" "$instance_alias_dir_a/modules.json")
	module_id_a=$(sed -e's/\\"/%22/g' "$instance_alias_dir_a/modules.json" | jq -r "select(.Name == \"${module_name_decoded//\"/%22}\") | .Id" | dos2unix)
       out_file="$helper/output_$module_json"

        # Contact Flow Module template file
        # module_template_file=$helper/module_template.json

        cat "$instance_alias_dir_a/$module_json" |
        sed -f "$helper_sed" > "$helper/$module_json"

        cat <<EOD >> "$helper_log"

$actionLead Create contact flow module: $module_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-create contact flow module
--instance-id $instance_id_b
--name "$module_name_decoded"

EOD
            cat <<EOD >> "$helper_log"
aws connect create-contact-flow-module \
--instance-id $instance_id_b \
--name "$module_name_decoded" \
--content "file://$helper/$module_json" \
> "$out_file"
EOD
            # rm "$helper/$module_json"
            continue
        fi

	## Get module description and use during module creation
	md="$instance_alias_dir_a/moduledesc_${module_name}"
	if [ -s "$md" ]; then
		module_desc=`cat "$md"`
	fi
	if [ "$module_desc" = "" -o "$module_desc" = null ]; then
		module_desc="$module_name_decoded"
	fi

        aws_connect create-contact-flow-module \
            --instance-id $instance_id_b \
            --name "$module_name_decoded" \
            --description "$module_desc" \
            --content "file://$helper/$module_json" \
            > "$out_file" || error $LINENO
	module_id_b=$(jq -r ".Id" "$out_file" | dos2unix)

        # All flows will be updated with content
        # echo "$module_json" >> $TEMPOLD

        aws_connect describe-contact-flow-module \
            --instance-id $instance_id_b \
            --contact-flow-module-id $module_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r '.ContactFlowModule.Content' > "$instance_alias_dir_b/$module_json"

## Creating list of newly created resources that can be deleted from instance B
	echo "module_${module_name_decoded}|$module_id_b" >> $helper_del
###############

        # Moving module_json from helper_new to helper_old
        echo "$module_json" >> "$helper_old"
        sed -e"/$module_json/d" "$helper_new" > $TEMPFILE
        cat $TEMPFILE > "$helper_new"

        cat <<EOD >> "$helper_sed"
# Contact Flow Module: $module_name_decoded
s%$module_id_a%$module_id_b%g
EOD
    done
    test $? -eq 0 || error

    if [ -z "$dryrun" ]; then
        # Update instance B flow modules
        aws_connect list-contact-flow-modules \
            --instance-id $instance_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r ".ContactFlowModulesSummaryList[] | select(.Name | test(\"^($contact_flow_prefix|Default ).*\"))" \
        > "$instance_alias_dir_b/modules.json"
    fi
fi


cat <<EOD

Contact Flow Modules Update
---------------------------
EOD

if [ ! -s $TEMPOLD ]; then
    echo "No contact flow modules to update"
else
    num_modules=$(echo $(cat $TEMPOLD | wc -l))
    echo -e "\nChecking $num_modules contact flow modules$contact_flow_prefix_text for an update"
    ii=0
    sort $TEMPOLD |
    while read module_json; do
        ii=$[ii+1]
        echo -n "$ii. $module_json ... "
        module_name=${module_json#module_}
        module_name=${module_name%.json}
        module_name_decoded=$(path_decode "$module_name")

 	## we need to find exact module name match - use regular expressions ^ and $ ignoring case ("i")
	module_id_b=$(sed -e's/\\"/%22/g' "$instance_alias_dir_b/modules.json" | jq -r "select(.Name | match(\"^${module_name_decoded//\"/%22}$\";\"i\")) | .Id" | dos2unix)
	## if module name has some exception characters, lower-case/upper-case differences, brackets, etc. and if we cannot find the id then skip instead of generating error
	skip_module="n"
	if [ "$module_id_b" == "" ]; then
		module_id_b=$(sed -e's/\\"/%22/g' "$instance_alias_dir_b/modules.json" | jq -r "select(.Name == \"${module_name_decoded//\"/%22}\") | .Id" | dos2unix)
		if [ $module_id_b == "" ]; then
			skip_module="y"
		fi
	fi
 
        cat "$instance_alias_dir_a/$module_json" > $TEMPA
        cat "$instance_alias_dir_b/$module_json" > $TEMPB
        df=$(diff_files); echo $df; test "$df" == "same" && continue

        cat "$instance_alias_dir_a/$module_json" |
        sed -f "$helper_sed" > "$helper/$module_json"

        cat <<EOD >> "$helper_log"

$actionLead Update contact flow module: $module_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-update contact flow module
--instance-id $instance_id_b
--contact-flow-module-id $module_id_b

EOD
            cat <<EOD >> "$helper_log"
aws connect update-contact-flow-module-content \
--instance-id $instance_id_b \
--contact-flow-module-id $module_id_b \
--content "file://$helper/$module_json" \
> "$helper/output_content_$module_json"
EOD
            # rm "$helper/$module_json"
            continue
        fi

############################################################################
### Check if this is part of exception module that we have to skip updating
### (e.g. it can contain reference to claimed number from source account
###       set in "Set caller Id" block in outbound whisper or transfer flow

	cnt=`grep -f $flowExceptions "$instance_alias_dir_a/$module_json" | wc -l`
       	if [ $cnt -gt 0 -o "$skip_module" == "y" ]; then
        	echo "Skipping this update as it contains an exception - Either reference to claimed number from source instance, or hard-coded Agent queue ARN. Please update this module manually in destination account."
		echo "$module_json|$module_id_b" >> $helper_skip
	else
	        aws_connect update-contact-flow-module-content \
        	    --instance-id $instance_id_b \
            	--contact-flow-module-id $module_id_b \
            	--content "file://$helper/$module_json" \
            	> "$helper/output_content_$module_json" || error $LINENO
	fi
        aws_connect describe-contact-flow-module \
            --instance-id $instance_id_b \
            --contact-flow-module-id $module_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r '.ContactFlowModule.Content' > "$instance_alias_dir_b/$module_json"
    done
    test $? -eq 0 || error
fi



############################################################
#
# Contact Flows
#
# TODO:
#   - Use $helper/flow_template.json as a template to create new contact flows
#   - Use the Default special type contact flow to create special type contact flows
#   - Skip "Default " and "Sample " contact flows

cat <<EOD

Contact Flows Creation
----------------------
EOD

# Preload as $helper_old may change
## Changing egrep to only use "flow_" Original egrep is commented out and updated on added below that
## egrep "^flow_$contact_flow_prefix" "$helper_old" | egrep -v "^flow_Default |^flow_Sample " > $TEMPOLD
egrep "^flow_" "$helper_old" | egrep -v "^flow_Default |^flow_Sample " > $TEMPOLD
# Create what is in $helper_new
## Changing egrep to only use "flow_" Original egrep is commented out and updated on added below that
## egrep "^flow_$contact_flow_prefix" "$helper_new" > $TEMPNEW
egrep "^flow_" "$helper_new" > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
    echo "No contact flows$contact_flow_prefix_text to create"
else
    num_flows=$(echo $(cat $TEMPNEW | wc -l))
    echo -e "\nCreating $num_flows contact flows$contact_flow_prefix_text"
    ii=0
    sort $TEMPNEW |
    while read flow_json; do
        ii=$[ii+1]
        echo "$ii. $flow_json"
        flow_name=${flow_json#flow_}
        flow_name=${flow_name%.json}
        flow_name_decoded=$(path_decode "$flow_name")

        # flow_type=$(jq -r "select(.Name == \"${flow_name_decoded//\"/\\\"}\") | .ContactFlowType" "$instance_alias_dir_a/flows.json")
	flow_type=$(sed -e's/\\"/%22/g' "$instance_alias_dir_a/flows.json" | jq -r "select(.Name == \"${flow_name_decoded//\"/%22}\") | .ContactFlowType" | dos2unix)
        # flow_id_a=$(jq -r "select(.Name == \"${flow_name_decoded//\"/\\\"}\") | .Id" "$instance_alias_dir_a/flows.json")
	flow_id_a=$(sed -e's/\\"/%22/g' "$instance_alias_dir_a/flows.json" | jq -r "select(.Name == \"${flow_name_decoded//\"/%22}\") | .Id" | dos2unix)

        out_file="$helper/output_$flow_json"

        # Contact Flow template file
        flow_template_file=$helper/flow_template.json
        case "$flow_type" in
        CUSTOMER_QUEUE)
            flow_template_file="$instance_alias_dir_b/flow_Default%20customer%20queue.json";;
        CUSTOMER_HOLD)
            flow_template_file="$instance_alias_dir_b/flow_Default%20customer%20hold.json";;
        CUSTOMER_WHISPER)
            flow_template_file="$instance_alias_dir_b/flow_Default%20customer%20whisper.json";;
        AGENT_HOLD)
            flow_template_file="$instance_alias_dir_b/flow_Default%20agent%20hold.json";;
        AGENT_WHISPER)
            flow_template_file="$instance_alias_dir_b/flow_Default%20agent%20whisper.json";;
        OUTBOUND_WHISPER)
            flow_template_file="$instance_alias_dir_b/flow_Default%20outbound.json";;
        AGENT_TRANSFER)
            flow_template_file="$instance_alias_dir_b/flow_Default%20agent%20transfer.json";;
        QUEUE_TRANSFER)
            flow_template_file="$instance_alias_dir_b/flow_Default%20queue%20transfer.json";;
        esac

        cat <<EOD >> "$helper_log"

$actionLead Create contact flow: $flow_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-create contact flow from Template (Default flows)
--instance-id $instance_id_b
--name "$flow_name_decoded"
--type $flow_type

EOD
            cat <<EOD >> "$helper_log"
aws connect create-contact-flow \
--instance-id $instance_id_b \
--name "$flow_name_decoded" \
--type $flow_type \
--content "file://$flow_template_file" \
> "$out_file"
EOD
            continue
        fi

	## Get flow description and use during flow creation
	fd="$instance_alias_dir_a/flowdesc_${flow_name_decoded}"
	if [ -s "$fd" ]; then
		flow_desc=`cat "$fd"`
	fi
	if [ "$flow_desc" = "" -o "$flow_desc" = null ]; then
		flow_desc="$flow_name_decoded"
	fi
        aws_connect create-contact-flow \
            --instance-id $instance_id_b \
            --name "$flow_name_decoded" \
            --type $flow_type \
            --description "$flow_desc" \
            --content "file://$flow_template_file" \
            > "$out_file" || error $LINENO
		    flow_id_b=$(jq -r ".ContactFlowId" "$out_file" | dos2unix)

        # All flows will be updated with content
        echo "$flow_json" >> $TEMPOLD

        aws_connect describe-contact-flow \
            --instance-id $instance_id_b \
            --contact-flow-id $flow_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r '.ContactFlow.Content' > "$instance_alias_dir_b/$flow_json"

## Creating list of newly created resources that can be deleted from instance B
	echo "flow_${flow_name_decoded}|$flow_id_b" >> $helper_del
###############

        # Moving flow_json from helper_new to helper_old
        echo "$flow_json" >> "$helper_old"
        sed -e"/$flow_json/d" "$helper_new" > $TEMPFILE
        cat $TEMPFILE > "$helper_new"

        cat <<EOD >> "$helper_sed"
# Contact Flow: $flow_name_decoded
s%$flow_id_a%$flow_id_b%g
EOD
    done
    test $? -eq 0 || error

    if [ -z "$dryrun" ]; then
        # Update instance B flows
        aws_connect list-contact-flows \
            --instance-id $instance_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r ".ContactFlowSummaryList[] | select(.Name | test(\"^($contact_flow_prefix|Default ).*\"))" \
        > "$instance_alias_dir_b/flows.json"
    fi
fi


cat <<EOD

Contact Flows Update
--------------------
EOD

if [ ! -s $TEMPOLD ]; then
    echo "No contact flows to update"
else
    num_flows=$(echo $(cat $TEMPOLD | wc -l))
    echo -e "\nChecking $num_flows contact flows$contact_flow_prefix_text for an update"
    ii=0
    sort $TEMPOLD |
    while read flow_json; do
        ii=$[ii+1]
        echo -n "$ii. $flow_json ... "
        flow_name=${flow_json#flow_}
        flow_name=${flow_name%.json}
        flow_name_decoded=$(path_decode "$flow_name")

	## we need to find exact flow name match - use regular expressions ^ and $ ignoring case ("i")
	flow_id_b=$(sed -e's/\\"/%22/g' "$instance_alias_dir_b/flows.json" | jq -r "select(.Name | match(\"^${flow_name_decoded//\"/%22}$\";\"i\")) | .Id" | dos2unix)
	## if flow name has some exception characters, lower-case/upper-case differences, brackets, etc. and if we cannot find the id then skip instead of generating error
	skip_flow="n"
	if [ "$flow_id_b" == "" ]; then
		flow_id_b=$(sed -e's/\\"/%22/g' "$instance_alias_dir_b/flows.json" | jq -r "select(.Name == \"${flow_name_decoded//\"/%22}\") | .Id" | dos2unix)
		if [ $flow_id_b == "" ]; then
			skip_flow="y"
		fi
	fi

        cat "$instance_alias_dir_a/$flow_json" > $TEMPA
        cat "$instance_alias_dir_b/$flow_json" > $TEMPB
        df=$(diff_files); echo $df; test "$df" == "same" && continue

        cat "$instance_alias_dir_a/$flow_json" |
        sed -f "$helper_sed" > "$helper/$flow_json"

        cat <<EOD >> "$helper_log"

$actionLead Update contact flow: $flow_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-update contact flow
--instance-id $instance_id_b
--contact-flow-id $flow_id_b

EOD
            cat <<EOD >> "$helper_log"
aws connect update-contact-flow-content \
--instance-id $instance_id_b \
--contact-flow-id $flow_id_b \
--content "file://$helper/$flow_json" \
> "$helper/output_content_$flow_json"
EOD
            # rm "$helper/$flow_json"
            continue
        fi

############################################################################
### Check if this is part of exception flow that we have to skip updating
### (e.g. it can contain reference to claimed number from source account
###       set in "Set caller Id" block in outbound whisper or transfer flow

	cnt=`grep -f $flowExceptions "$instance_alias_dir_a/$flow_json" | wc -l`
       	if [ $cnt -gt 0 -o "$skip_flow" == "y" ]; then
        	echo "Skipping this update as it contains an exception - Either reference to claimed number from source instance, or hard-coded Agent queue ARN. Please update this flow manually in destination account."
		echo "$flow_json|$flow_id_b" >> $helper_skip
	else
	      aws_connect update-contact-flow-content \
      		      --instance-id $instance_id_b \
      	     	 --contact-flow-id $flow_id_b \
           	 --content "file://$helper/$flow_json" \
          	  > "$helper/output_content_$flow_json" || error $LINENO
	fi
        aws_connect describe-contact-flow \
            --instance-id $instance_id_b \
            --contact-flow-id $flow_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r '.ContactFlow.Content' > "$instance_alias_dir_b/$flow_json"
    done
    test $? -eq 0 || error
fi


############################################################
#
# Contact flows and modules association with Lambda functions
#

lambdaArnLead=arn:aws:lambda:$region_b:$aws_ac_b:function:
cat \
    "$instance_alias_dir_b/flow_"* \
    "$instance_alias_dir_b/module_"* 2> /dev/null |
    jq -r ".Actions[] | select(.Type == \"InvokeLambdaFunction\") | .Parameters.LambdaFunctionARN" | dos2unix |
    grep "$lambdaArnLead" |
    sort -u > $TEMPFILE

if [ -s $TEMPFILE ]; then
    echo
    echo Associating Lambda functions to $instance_alias_b
    # Use "aws connect" instead of "aws_connect" to avoid logging
aws connect list-lambda-functions \
$profile_flag \
--instance-id $instance_id_b \
> $TEMPOLD || error $LINENO
    cat $TEMPOLD |
    jq -r ".LambdaFunctions" > "$helper/lambds.json"

    ii=0
    cat $TEMPFILE |
    while read lambdaArn; do
        ii=$[ii+1]
        echo -n "$ii. $lambdaArn ... "
        lambdaExist=$(echo $(cat "$helper/lambds.json" | jq ".[] | select(. == \"$lambdaArn\")" | wc -l))
        if [ "$lambdaExist" -gt 0 ]; then
            echo "already associated"
            continue
        fi
        echo "to be associated"
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-associating lambda function
--instance-id $instance_id_b \
--function-arn $lambdaArn \


EOD
            cat <<EOD >> "$helper_log"

aws connect associate-lambda-function \
--instance-id $instance_id_b \
--function-arn $lambdaArn
EOD
            continue
        fi
        aws_connect associate-lambda-function \
            --instance-id $instance_id_b \
            --function-arn $lambdaArn || error $LINENO
    done
fi

############################################################
#
# Quick Connects
#

cat <<EOD

Quick Connects
-----------------
EOD

# Preload as $helper_old may change
egrep "^quickconnect_" "$helper_old" > $TEMPOLD
# Create what is in $helper_new
egrep "^quickconnect_" "$helper_new" > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
	echo "No Quick Connects to create"
else
	num_qc=$(echo $(cat $TEMPNEW | wc -l))
	echo -e "\nCreating $num_qc Quick Connects"
	ii=0
	sort $TEMPNEW |
	while read qc_json; do
		ii=$[ii+1]
		echo "$ii. $qc_json"
		qc_name=${qc_json#quickconnect_}
		qc_name=${qc_name%.json}
	        qc_name_decoded=$(path_decode "$qc_name")
		qc_id_a=$(jq -r ".QuickConnect.QuickConnectId" "$instance_alias_dir_a/$qc_json" | dos2unix)
		cat "$instance_alias_dir_a/$qc_json" |
			jq --arg instance_id $instance_id_b \
			".QuickConnect | del(.QuickConnectARN, .QuickConnectId) | . + { InstanceId: \$instance_id}" |
			sed -f "$helper_sed" > "$helper/$qc_json"

		cat <<EOD >> "$helper_log"
$actionLead Create Quick Connect: $qc_name_decoded
EOD

		if [ -n "$dryrun" ]; then
			cat <<EOD
			Dry-create Quick Connect
			$(cat "$helper/$qc_json")

EOD
            		cat <<EOD >> "$helper_log"
aws connect create-quick-connect \
--cli-input-json "file://$helper/$qc_json" \
> "$helper/output_$qc_json"
EOD
			# rm "$helper/$qc_json"
	                continue
		fi

############################################################################
### Check if this is part of exception that we have to skip 
### (e.g. quick connect is of type USER
	    cnt=`grep -f $flowExceptions "$instance_alias_dir_a/$qc_json" | wc -l`
       	    if [ $cnt -gt 0 ]; then
        	echo "Skipping this quick connect as it contains an exception - May have quick connect type as USER. Please update this quick connect manually in destination account."
		echo "$qc_json|dummyid" >> $helper_skip
   	    else
		aws_connect create-quick-connect \
			--cli-input-json "file://$helper/$qc_json" \
			> "$helper/output_$qc_json" || error $LINENO
		qc_id_b=$(jq -r ".QuickConnectId" "$helper/output_$qc_json" | dos2unix)

		aws_connect describe-quick-connect \
			--instance-id $instance_id_b \
			--quick-connect-id $qc_id_b \
			> "$instance_alias_dir_b/$qc_json" || error $LINENO

## Creating list of newly created resources that can be deleted from instance B
		echo "qc_${qc_name_decoded}|$qc_id_b" >> $helper_del

###############
		# Moving qc_json from helper_new to helper_old
		echo $qc_json >> "$helper_old"
		sed -e"/$qc_json/d" "$helper_new" > $TEMPFILE
		cat $TEMPFILE > "$helper_new"
		cat <<EOD >> "$helper_sed"

		# Quick Connect: $qc_name_decoded
		s%$qc_id_a%$qc_id_b%g
EOD
	    fi
    	done
    	test $? -eq 0 || error

	if [ -z "$dryrun" ]; then
		# Update instance B quick connects
		aws_connect list-quick-connects \
			--instance-id $instance_id_b \
			> $TEMPFILE || error $LINENO
		cat $TEMPFILE |
			jq -r ".QuickConnectSummaryList[]" > "$instance_alias_dir_b/quickconnects.json"
	fi
fi

### Let's check if we need to update any quick connects
if [ ! -s $TEMPOLD ]; then
	    echo "No Quick Connects to update"
    else
	num_qc=$(echo $(cat $TEMPOLD | wc -l))
        echo -e "\nChecking $num_qc Quick Connects for an update"
	ii=0
	sort $TEMPOLD |
	while read qc_json; do
        ii=$[ii+1]
	    echo -n "$ii. $qc_json ... "
        qc_config_json="quickconnect_config_"${qc_json#quickconnect_}
        qc_name_json="quickconnect_name_"${qc_json#quickconnect_}

        ## See if there is any update required in destination quick connect

        ## Let's see if we have to update quick connect configuration
        cat "$instance_alias_dir_a/$qc_json" |  jq ".QuickConnect | del(.QuickConnectARN, .Name, .Description, .Tags)" > $TEMPA
        cat "$instance_alias_dir_b/$qc_json" |  jq ".QuickConnect | del(.QuickConnectARN, .Name, .Description, .Tags)" > $TEMPB
		df=$(diff_files); echo $df; test "$df" == "same" && continue
        ## we have to update the quick connect configuration
        ### Check if this is part of exception that we have to skip (e.g. quick connect is of type USER)
   	    cnt=`grep -f $flowExceptions "$instance_alias_dir_a/$qc_json" | wc -l`
   	    if [ $cnt -gt 0 ]; then
           	echo "Skipping this update - Quick connect type is USER. Please update this quick connect manually in destination instance"
        	echo "$qc_json|dummyid" >> $helper_skip
            continue
        fi
        cat $TEMPA | jq --arg iid $instance_id_b ". + { InstanceId: \$iid }" | sed -f "$helper_sed" > "$helper/$qc_config_json"
  		if [ -n "$dryrun" ]; then
    		cat <<EOD
Dry-update quick connect configuration
$(cat "$helper/$qc_config_json")
EOD
       		cat <<EOD >> "$helper_log"
aws connect update-quick-connect-config \
--cli-input-json "file://$helper/$qc_config_json" \
> "$helper/output_$qc_config_json"
EOD
            continue
        fi

        ## Not a dry-run update quick connect configuration
   	    aws_connect update-quick-connect-config \
                --cli-input-json "file://$helper/$qc_config_json" \
                > "$helper/output_$qc_config_json" || error $LINENO

	done
    test $? -eq 0 || error
fi

############################################################
#
# Update Queue - Outbound Config
#   If we have phone mapping then we will update phone number from instance b
#   else we will only update outbound whisper flow in the queue
#
#
cat <<EOD

Queues - Outbound caller configuration
------
EOD

# Preload as $helper_old may change
egrep "^queue_" "$helper_old" > $TEMPOLD
if [ ! -s $TEMPOLD ]; then
    echo "No queues to update for outbound caller configuration"
else
    num_queues=$(echo $(cat $TEMPOLD | wc -l))
    echo -e "\nChecking $num_queues queues for outbound caller configuration"
    ii=0
    sort $TEMPOLD |
    while read queue_json; do
        outboundconfig=n
        ii=$[ii+1]
        queue_outboundcaller_json="queue_outboundcaller_"${queue_json#queue_}
        echo -n "$ii. $queue_outboundcaller_json ... "
        ## Let's extract outbound caller Id number Id and whisper flow Id - These will be used to ensure target is updated correctly
        ## We need to take care of many variations here
        ### e.g. Both, caller Id and whisper flow id exists in source but not in destination
        #######  only caller Id exists in source but not in destination
        #######  only whisper id exists in source but not in destination
        #######  And vice-a versa like caller Id and whisper flow id does not exist in source but exist in destination (it was deleted in source after initial sync to destination)
        ######   caller Id exists in source but whisper id exists in dest; whisper Id exists in source but caller id in dest and so forth.....

        outboundCallerId_a=$(jq -r ".Queue.OutboundCallerConfig.OutboundCallerIdNumberId" "$instance_alias_dir_a/$queue_json" | dos2unix)
        outboundWhisperFlow_a=$(jq -r ".Queue.OutboundCallerConfig.OutboundFlowId" "$instance_alias_dir_a/$queue_json" | dos2unix)
        outboundWhisperFlow_b=$(jq -r ".Queue.OutboundCallerConfig.OutboundFlowId" "$instance_alias_dir_b/$queue_json" | dos2unix)
        outboundCallerId_b=$(jq -r ".Queue.OutboundCallerConfig.OutboundCallerIdNumberId" "$instance_alias_dir_b/$queue_json" | dos2unix)
        ## If we have phone mapping then leave the outbound caller Id number Id in it else remove it
        if [ "$flowExceptions" = "$phoneMapping" ]; then
            ## we have phone mapping, so leave the outbound caller Id number Id
            cat "$instance_alias_dir_a/$queue_json" | jq ".Queue | del(.Name, .QueueArn, .Description, .HoursOfOperationId, .Status, .MaxContacts, .Tags)" > $TEMPA
            cat "$instance_alias_dir_b/$queue_json" | jq ".Queue | del(.Name, .QueueArn, .Description, .HoursOfOperationId, .Status, .MaxContacts, .Tags)" > $TEMPB
            df=$(diff_files); echo $df; test "$df" == "same" && continue

            ## There is some difference between source queue and destination queue for outbound configuration
            outboundconfig=y
            ## Let's check if we had data for outbound caller Id number Id and whisper flow Id from the queue of source instance
            if [ "$outboundCallerId_a" = "null" -a "$outboundWhisperFlow_a" = "null" ]; then
                ## This can happen if both, caller Id and whisper flow, are deleted from the queue of source instance - we will have to remove it from dest instance
                cat $TEMPA | jq '. + { "OutboundCallerConfig": {} }' > $TEMPB
                cat $TEMPB > $TEMPA
            fi
        else
            ## we do not have phone mapping, so remove the outbound caller Id number Id (only caller Id name and outbound whisper flow Id will be updated)
            ## But first lets' check if we have outbound caller Id number Id - if it exists we have to note this as manual update
            if [ "$outboundCallerId_a" != "null" ]; then
                ## phone mapping is not configured and queue contains outbound caller id number - so this will be a manual update for outbound caller id number
                echo "Queue contains outbound caller id number...you may have to update corresponding outbound caller id number manually in destination queue"
                echo "$queue_json|queue_outboundcaller" >> $helper_skip
            fi

            if [ "$outboundCallerId_a" = "null" -a "$outboundCallerId_b" != "null" ]; then
                echo "Outbound caller Id was removed from source queue...you may have to remove corresponding outbound caller id number manually in destination queue"
                echo "$queue_json|queue_outboundcaller" >> $helper_skip
            fi

            ## If whisper flow is different in source/destination then We will still update the outbound whisper flow Id in destination but remove outbound caller id number id
            cat "$instance_alias_dir_a/$queue_json" | 
            jq ".Queue | del(.Name, .QueueArn, .Description, .HoursOfOperationId, .Status, .MaxContacts, .Tags, .OutboundCallerConfig.OutboundCallerIdNumberId)" > $TEMPA
            cat "$instance_alias_dir_b/$queue_json" | 
            jq ".Queue | del(.Name, .QueueArn, .Description, .HoursOfOperationId, .Status, .MaxContacts, .Tags, .OutboundCallerConfig.OutboundCallerIdNumberId)" > $TEMPB
            df=$(diff_files); echo $df; test "$df" == "same" && continue
            if [ "$outboundWhisperFlow_a" = "null" -a "$outboundWhisperFlow_b" = "null" ]; then
                continue
            fi

            ## There is some difference between source queue and destination queue for outbound configuration
            outboundconfig=y
            ## We have to update dest instance, but first lets' check if we have outbound whisper flow configured in this queue in source instance
            ## This can happen if outbound whisper flow was deleted from the queue of source instance - we will have to remove it from dest instance
            if [ "$outboundWhisperFlow_a" = "null" ]; then
                cat $TEMPA | jq '. + { "OutboundCallerConfig": {} }' > $TEMPB
                cat $TEMPB > $TEMPA
            fi
        fi

        ## If we don't have any update then continue
        test "$outboundconfig" == "n" && continue

	    ## We need to update outbound caller configuration and/or outbound whisper flow to this queue
        cat "$TEMPA" | jq --arg instance_id $instance_id_b ". + { InstanceId: \$instance_id}" | sed -f "$helper_sed" > "$helper/$queue_outboundcaller_json"

		if [ -n "$dryrun" ]; then
			cat <<EOD
			Dry-update Queue outbound configuration
			$(cat "$helper/$queue_outboundcaller_json")
EOD
            		cat <<EOD >> "$helper_log"
aws connect update-queue-outbound-caller-config \
--cli-input-json "file://$helper/$queue_outboundcaller_json" \
> "$helper/output_$queue_outboundcaller_json"
EOD
            continue
		fi

	    aws_connect update-queue-outbound-caller-config \
            --cli-input-json "file://$helper/$queue_outboundcaller_json" \
            > "$helper/output_$queue_hours_json" || error $LINENO
    done
fi

############################################################
#
# Associate Quick Connects to Queues
#
#
cat <<EOD

Queues - Quick Connects
------
EOD

# Preload as $helper_old may change
egrep "^queue_" "$helper_old" > $TEMPOLD
if [ ! -s $TEMPOLD ]; then
    echo "No queues to update with quick connects"
else
    num_queues=$(echo $(cat $TEMPOLD | wc -l))
    echo -e "\nChecking $num_queues queues for quick connect association"
    ii=0
    sort $TEMPOLD |
    while read queue_json; do
        ii=$[ii+1]
        queue_qc_json="queue_qc_"${queue_json#queue_}
        echo -n "$ii. $queue_qc_json ... "
        cat "$instance_alias_dir_a/$queue_qc_json" > $TEMPA
        cat "$instance_alias_dir_b/$queue_qc_json" > $TEMPB
        df=$(diff_files); echo $df; test "$df" == "same" && continue

		## We need to associate quick connect to this queue
		queue_id_b=$(jq -r ".Queue.QueueId" "$instance_alias_dir_b/$queue_json" | dos2unix)
	        cat "$instance_alias_dir_a/$queue_qc_json" | sed -f "$helper_sed" > "$helper/$queue_qc_json"
		## Associate all quick connects to this queue but skip the quick connect type USER
		cat "$helper/$queue_qc_json" | jq -r ".QuickConnectSummaryList[] | select (.QuickConnectType != \"USER\") | .Id" | dos2unix |
		while read qcid; do
        	if [ -z "$dryrun" ]; then
		    	aws_connect associate-queue-quick-connects \
			    	--instance-id $instance_id_b --queue-id $queue_id_b --quick-connect-ids $qcid \
				    > $TEMPFILE || error $LINENO
        		cnt=`cat "$helper/$queue_qc_json" | jq -r ".QuickConnectSummaryList[] | select (.QuickConnectType == \"USER\") | .Id" | dos2unix | wc -l`
        		if [ "$cnt" -gt "0" ]; then
        			## There is a quick connect in this queue of type USER - Mark it to update this queue manually
		        	echo "$queue_qc_json|qQC" >> $helper_skip
        		fi
            else
    			cat <<EOD
	    		Dry-create Queue quick connect configuration
		    	$(cat "$helper/$queue_qc_json")
EOD
            cat <<EOD >> "$helper_log"
aws_connect associate-queue-quick-connects \
--instance-id $instance_id_b --queue-id $queue_id_b --quick-connect-ids $qcid \
> "$helper/output_$queue_hours_json"
EOD
                continue
            fi
		done
    done
fi


###########################################################################################################
### Let's check if we skipped to update any resources
## Check if we skipped routing profile update
cat <<EOD >> "$helper_log"
******************* Possible actions in destination instance *******************
******************* Please check these resources in destination instance *******************
EOD

echo
echo
echo
echo "******************* Possible actions in destination instance *******************"
echo "******************* Please check these resources in destination instance *******************"
for resource in hour queue routing module flow quickconnect; do
	case "$resource" in
   	"hour")
      	   rsc_desc="Hours of operation"
 	   ;;
   	"queue")
      	   rsc_desc="Queues"
 	   ;;
   	"routing")
      	   rsc_desc="Routing profiles"
 	   ;;
   	"module")
      	   rsc_desc="Contact Module"
 	   ;;
   	"flow")
      	   rsc_desc="Contact flows"
 	   ;;
   	"quickconnect")
      	   rsc_desc="Quick connects"
 	   ;;
	esac

        > $TEMPNEW
        egrep "^${resource}_" "$helper_skip" > $TEMPNEW
        if [ -s $TEMPNEW ]; then
            num_hours=$(echo $(cat $TEMPNEW | wc -l))
cat <<EOD >> "$helper_log"
            Skipped $num_hours "$rsc_desc" for create/update
EOD
            echo -e "\nSkipped $num_hours "$rsc_desc" for create/update"
            ii=0
            sort $TEMPNEW |
            while read line1; do
                ii=$[ii+1]
                resource_json=`echo $line1 | cut -d'|' -f1`
                resource_id=`echo $line1 | cut -d'|' -f2`
                resource_name=${resource_json#${resource}_}
                resource_name=${resource_name%.json}
		if [ "$resource_id" == "qQC" ]; then
	                resource_name=${resource_name#qc_}
cat <<EOD >> "$helper_log"
	                $ii. Quick connects in queue: $resource_name
EOD
	                echo "$ii. Quick connects in queue: $resource_name"
		else
cat <<EOD >> "$helper_log"
	                $ii. $resource_name
EOD
	                echo "$ii. $resource_name"
		fi
            done
        fi
done
cat <<EOD >> "$helper_log"
*********************************************
EOD
echo "*********************************************"

##############################################
num_actions=$(echo $(egrep "^$actionLead" "$helper_log" | wc -l))
echo
#echo "$num_actions actions on the target instance"
if [ "$num_actions" -eq 0 ]; then
    echo "Target instance is the same as the source instance. No updates are required."
    exit 3
else
    echo
##    cat "$helper_log"
##    echo
    if [ -n "$dryrun" ]; then
        echo "No actions were carried out in Dry-run mode"
    else
cat <<EOD >> "$helper_log"
        All done
EOD
        echo "All done"
    fi
fi
